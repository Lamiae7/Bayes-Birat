---
title: ''
author: "CHERQI Meryem - ARIFALLAH Lamiae - YOUSFI Rym "
date: "2024-04-15"
output:
  html_document:
    df_print: paged
  pdf_document: default
editor_options: 
  markdown: 
    wrap: sentence
---

```{r}
init <- list(mu.beta = c(0,0), tauC = 1,
		      beta = structure(
				.Data = c(100,6,100,6,100,6,100,6,100,6,
		               100,6,100,6,100,6,100,6,100,6,
		               100,6,100,6,100,6,100,6,100,6,
		               100,6,100,6,100,6,100,6,100,6,
		               100,6,100,6,100,6,100,6,100,6,
		               100,6,100,6,100,6,100,6,100,6),
				.Dim = c(30, 2)),
		      R = structure(.Data = c(1,0,0,1), .Dim = c(2, 2)))  		      
		      
		      names(inits)
		      inits$R
		      is.matrix(inits$beta)
		      is.matrix(inits$R)
```


```{r}
# MODEL definition --------------------------------------------------------
Data = list(x = c(8.0, 15.0, 22.0, 29.0, 36.0), N = 30, T = 5, Omega = structure(.Data = c(200, 0, 0, 0.2), .Dim = c(2, 2)),  mean = c(0,0),prec = structure(.Data = c(1.0E-6, 0, 0, 1.0E-6), .Dim = c(2, 2)),
            Y = structure(
              .Data = c(151, 199, 246, 283, 320,
                        145, 199, 249, 293, 354,
                        147, 214, 263, 312, 328,
                        155, 200, 237, 272, 297,
                        135, 188, 230, 280, 323,
                        159, 210, 252, 298, 331,
                        141, 189, 231, 275, 305,
                        159, 201, 248, 297, 338,
                        177, 236, 285, 350, 376,
                        134, 182, 220, 260, 296,
                        160, 208, 261, 313, 352,
                        143, 188, 220, 273, 314,
                        154, 200, 244, 289, 325,
                        171, 221, 270, 326, 358,
                        163, 216, 242, 281, 312,
                        160, 207, 248, 288, 324,
                        142, 187, 234, 280, 316,
                        156, 203, 243, 283, 317,
                        157, 212, 259, 307, 336,
                        152, 203, 246, 286, 321,
                        154, 205, 253, 298, 334,
                        139, 190, 225, 267, 302,
                        146, 191, 229, 272, 302,
                        157, 211, 250, 285, 323,
                        132, 185, 237, 286, 331,
                        160, 207, 257, 303, 345,
                        169, 216, 261, 295, 333,
                        157, 205, 248, 289, 316,
                        137, 180, 219, 258, 291,
                        153, 200, 244, 286, 324),
              .Dim = c(30,5)))

model1="
   model
   {
       for( i in 1 : N ) {
          beta[i , 1 : 2] ~ dmnorm(mu.beta[], R[ , ])
          for( j in 1 : T ) {
             Y[i, j] ~ dnorm(mu[i , j], tauC)
             mu[i, j] <- beta[i, 1] + beta[i, 2] * x[j]
          }
       }

       mu.beta[1 : 2] ~ dmnorm(mean[], prec[ , ])
       R[1 : 2 , 1 : 2] ~ dwish(Omega[ , ], 2)
       tauC ~ dgamma(0.001, 0.001)
       sigma <- 1 / sqrt(tauC)
   }"
  
  
writeLines(model1,"model.text")
```


```{r}
# MCMC  -------------------------------------------------------------------
install.packages("rjags")

```
```{r}
library(rjags)

```
```{r}
install.packages("remotes")

```


```{r}
model1 = jags.model("model.text", inits = init,data = Data, n.chains =2)

update(model1,5000)
model1.samples = coda.samples(model=model1,variable.names = c("mu.beta[1]", "mu.beta[2]", "sigma"),n.iter = 10000)

summary(model1.samples)
```
```{r}
install.packages("ggmcmc")
```


```{r}
# basic plot and diagnostics ----------------------------------------------

library(ggmcmc)

#traceplot(model1.samples)
res = ggs(model1.samples)
ggs_density(res)

ggs_traceplot(res)

ggs_running(res)

ggs_autocorrelation(res)

```


```{r}
# Chargement des bibliothèques nécessaires
library(coda)
library(rjags)

# Assumant que 'model' est votre modèle JAGS déjà créé
# Extraction des chaînes pour les paramètres d'intérêt
mcmc_samples <- coda.samples(model1, variable.names = c("mu.beta[1]", "mu.beta[2]", "sigma"), n.iter = 10000)

```
```{r}
# Tracé des chaînes de Markov pour chaque paramètre
plot(mcmc_samples)

```
```{r}
# Trace plot pour mu.beta[1]
plot(mcmc_samples[, "mu.beta[1]"], main = "Trace Plot pour mu.beta[1]")

# Trace plot pour mu.beta[2]
plot(mcmc_samples[, "mu.beta[2]"], main = "Trace Plot pour mu.beta[2]")

# Trace plot pour sigma
plot(mcmc_samples[, "sigma"], main = "Trace Plot pour sigma")

```

```{r}
# Diagnostic de convergence pour les chaînes
gelman.diag(mcmc_samples)

```


```{r}
install.packages("coda,nlme")
```

```{r}
# Chargement des bibliothèques nécessaires
library(coda)
library(nlme)
library(ggplot2)

# Extraction des chaînes de l'échantillon du modèle
chain1 = model1.samples[[1]]
mu_beta1 = chain1[,"mu.beta[1]"]
mu_beta2 = chain1[,"mu.beta[2]"]
sigmach = chain1[,"sigma"]


```


```{r}
# Fonction de prédiction améliorée
predict_rat <- function(rat.x, n = 1000) {
  # Générer des échantillons pour alpha et beta
  alpha.i = rnorm(n, mean(mu_beta1), sd = sd(mu_beta1))
  beta.i = rnorm(n, mean(mu_beta2), sd = sd(mu_beta2))
  
  # Générer des échantillons pour les prédictions Y en utilisant les nouveaux x
  Ypred = alpha.i + beta.i * rat.x
  
  # Calculer l'intervalle HPD pour les prédictions
  inter = HPDinterval(as.mcmc(Ypred))
  
  # Retourner les résultats sous forme de vecteur
  c(inter[1], inter[2])
}

# Appliquer la fonction de prédiction pour un vecteur de valeurs x
intervaldata <- data.frame(x = 0:40)
predictions <- t(sapply(intervaldata$x, function(x) predict_rat(x, n = 1000)))

# Incorporer les prédictions dans le dataframe
intervaldata$min <- predictions[, 1]
intervaldata$max <- predictions[, 2]

# Visualisation avec ggplot2
fig <- ggplot(data = intervaldata, aes(x = x)) +
  geom_ribbon(aes(ymin = min, ymax = max), alpha = 0.3, fill = "blue") +
  geom_line(data = intervaldata, aes(y = (min + max) / 2), colour = "red") +
  labs(title = "Intervalles de prédiction pour Y", x = "Valeur de x", y = "Prédiction de Y")

print(fig)


```

```{r}
bidata <- list(x = c(8.0, 15.0, 22.0, 29.0, 36.0), N = 30, 
               Ti = 5,
     Omega = structure(.Data = c(200, 0, 0, 0.2), .Dim = c(2, 2)),   
     mean = c(0,0),
     prec = structure(.Data = c(1.0E-6, 0, 0, 1.0E-6), .Dim = c(2, 2)),
     Y = structure(
       .Data = c(151, 199, 246, 283, 320,
                 145, 199, 249, 293, 354,
                 147, 214, 263, 312, 328,
                 155, 200, 237, 272, 297,
                 135, 188, 230, 280, 323,
                 159, 210, 252, 298, 331,
                 141, 189, 231, 275, 305,
                 159, 201, 248, 297, 338,
                 177, 236, 285, 350, 376,
                 134, 182, 220, 260, 296,
                 160, 208, 261, 313, 352,
                 143, 188, 220, 273, 314,
                 154, 200, 244, 289, 325,
                 171, 221, 270, 326, 358,
                 163, 216, 242, 281, 312,
                 160, 207, 248, 288, 324,
                 142, 187, 234, 280, 316,
                 156, 203, 243, 283, 317,
                 157, 212, 259, 307, 336,
                 152, 203, 246, 286, 321,
                 154, 205, 253, 298, 334,
                 139, 190, 225, 267, 302,
                 146, 191, 229, 272, 302,
                 157, 211, 250, 285, 323,
                 132, 185, 237, 286, 331,
                 160, 207, 257, 303, 345,
                 169, 216, 261, 295, 333,
                 157, 205, 248, 289, 316,
                 137, 180, 219, 258, 291,
                 153, 200, 244, 286, 324),
       .Dim = c(30,5)))

bidata <- read.jagsdata("birats-data.R")

modelstring <- "
var
x[Ti],mu[N,Ti],Y[N,T],beta[N,2],mu.beta[2],Omega.beta[2,2],
Sigma2.beta[2,2],sigma.beta[2],tau.c,sigma,R[2,2],r,alpha0;
model {
for (i in 1:N) {
for (j in 1:Ti) {
Y[i,j] ~ dnorm(mu[i,j],tau.c); #
mu[i,j] <- beta[i,1] + beta[i,2] * x[j];
}
beta[i,] ~ dmnorm(mu.beta[],Omega.beta[,]); # bivariate Normal
}
tau.c ~ dgamma(1.0E-3,1.0E-3);
sigma <- 1.0/sqrt(tau.c);
# parameters considered MVN
Omega.beta[,] ~ dwish(R[,],2); # Wishart prior
Sigma2.beta[,] <- inverse(Omega.beta[,]);
sigma.beta[1]<-sqrt(Sigma2.beta[1,1]);
sigma.beta[2]<-sqrt(Sigma2.beta[2,2]);
r <- Sigma2.beta[1,2] / (sqrt(Sigma2.beta[1,1])
*sqrt(Sigma2.beta[2,2])); # correlation
mu.beta[1] ~ dnorm(0,.00001); # `flat' univariate Normal prior on mean
mu.beta[2] ~ dnorm(0,.00001); # `flat' univariate Normal prior on mean
}
"

writeLines(modelstring, "model3.txt")

init <- read.jagsdata("birats-inits.R")

mod3 <- jags.model("model3.txt",inits = init, data=bidata, n.chains=2)
```
```{r}


## Data
birats = Dict{Symbol, Any}(
  :N => 30, :T => 5,
  :x => [8.0, 15.0, 22.0, 29.0, 36.0],
  :Y => [151 199 246 283 320
         145 199 249 293 354
         147 214 263 312 328
         155 200 237 272 297
         135 188 230 280 323
         159 210 252 298 331
         141 189 231 275 305
         159 201 248 297 338
         177 236 285 350 376
         134 182 220 260 296
         160 208 261 313 352
         143 188 220 273 314
         154 200 244 289 325
         171 221 270 326 358
         163 216 242 281 312
         160 207 248 288 324
         142 187 234 280 316
         156 203 243 283 317
         157 212 259 307 336
         152 203 246 286 321
         154 205 253 298 334
         139 190 225 267 302
         146 191 229 272 302
         157 211 250 285 323
         132 185 237 286 331
         160 207 257 303 345
         169 216 261 295 333
         157 205 248 289 316
         137 180 219 258 291
         153 200 244 286 324],
  :mean => [0.0, 0.0],
  :var => [1.0e6 0.0
           0.0   1.0e6],
  :Omega => [200.0 0.0
               0.0 0.2]
)


## Model Specification
model = Model(

  Y = Stochastic(2,
    (beta, x, sigmaC, N, T) ->
      UnivariateDistribution[
        Normal(beta[i, 1] + beta[i, 2] * x[j], sigmaC)
        for i in 1:N, j in 1:T
      ],
    false
  ),

  beta = Stochastic(2,
    (mu_beta, Sigma, N) ->
      MultivariateDistribution[
        MvNormal(mu_beta, Sigma)
        for i in 1:N
      ],
    false
  ),

  mu_beta = Stochastic(1,
    (mean, var) -> MvNormal(mean, var)
  ),

  Sigma = Stochastic(2,
    Omega -> InverseWishart(2, Omega),
    false
  ),

  sigma2C = Stochastic(
    () -> InverseGamma(0.001, 0.001),
    false
  ),

  sigmaC = Logical(
    sigma2C -> sqrt(sigma2C)
  )

)


## Initial Values
inits = [
  Dict(:Y => birats[:Y], :beta => repeat([100 6], birats[:N], 1),
       :mu_beta => [0, 0], :Sigma => Matrix{Float64}(I, 2, 2), :sigma2C => 1.0),
  Dict(:Y => birats[:Y], :beta => repeat([50 3], birats[:N], 1),
       :mu_beta => [10, 10], :Sigma => 0.3 * Matrix{Float64}(I, 2, 2), :sigma2C => 10.0)
]


## Sampling Scheme
scheme = [AMWG([:beta, :mu_beta], repeat([10.0, 1.0], birats[:N] + 1)),
          AMWG(:Sigma, 1.0),
          Slice(:sigma2C, 10.0)]
setsamplers!(model, scheme)


## MCMC Simulations
sim = mcmc(model, birats, inits, 10000, burnin=2500, thin=2, chains=2)
describe(sim)
```
```{r}
library(rjags)

# Data preparation
N <- 30
Ti <- 5
xb <- 22
x <- c(8.0, 15.0, 22.0, 29.0, 36.0)
Y <- matrix(c(151, 199, 246, 283, 320,
                 145, 199, 249, 293, 354,
                 147, 214, 263, 312, 328,
                 155, 200, 237, 272, 297,
                 135, 188, 230, 280, 323,
                 159, 210, 252, 298, 331,
                 141, 189, 231, 275, 305,
                 159, 201, 248, 297, 338,
                 177, 236, 285, 350, 376,
                 134, 182, 220, 260, 296,
                 160, 208, 261, 313, 352,
                 143, 188, 220, 273, 314,
                 154, 200, 244, 289, 325,
                 171, 221, 270, 326, 358,
                 163, 216, 242, 281, 312,
                 160, 207, 248, 288, 324,
                 142, 187, 234, 280, 316,
                 156, 203, 243, 283, 317,
                 157, 212, 259, 307, 336,
                 152, 203, 246, 286, 321,
                 154, 205, 253, 298, 334,
                 139, 190, 225, 267, 302,
                 146, 191, 229, 272, 302,
                 157, 211, 250, 285, 323,
                 132, 185, 237, 286, 331,
                 160, 207, 257, 303, 345,
                 169, 216, 261, 295, 333,
                 157, 205, 248, 289, 316,
                 137, 180, 219, 258, 291,
                 153, 200, 244, 286, 324), nrow=N, ncol= Ti, byrow=TRUE)

mean <- c(0, 0)
var_prior <- diag(c(1e6, 1e6))
Omega <- matrix(c(200.0, 0, 0, 0.2), nrow=2, byrow=TRUE)

# JAGS model
model_string <- "
   model
   {
      for( i in 1 : N ) {
         for( j in 1 : Ti ) {
            Y[i , j] ~ dnorm(mu[i , j],tau.c)
            mu[i , j] <- alpha[i] + beta[i] * (x[j] - xb)
         }
         alpha[i] ~ dnorm(alpha.c,alpha.tau)
         beta[i] ~ dnorm(mu_beta2,tauC)
      }
      tau.c ~ dgamma(0.001,0.001)
      sigma <- 1 / sqrt(tau.c)
      alpha.c ~ dnorm(0.0,1.0E-6)   
      alpha.tau ~ dgamma(0.001,0.001)
      mu_beta2 ~ dnorm(0.0,1.0E-6)
      tauC ~ dgamma(0.001,0.001)
      mu_beta1 <- alpha.c - xb * mu_beta2   
   }"

# Data list for JAGS
data_jags <- list(Y = Y, N = N, Ti = Ti, x = x, xb= xb, mean = mean, var_prior = var_prior, Omega = Omega)

# Initial values
inits <- function() {
list(alpha = c(250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
                  250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250),
      beta = c(6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6),         
      alpha.c = 150, mu_beta2 = 10,
      tau.c = 1, alpha.tau = 1, tauC = 1)}

# Parameters to monitor
params <- c("mu_beta1", "mu_beta2","sigma")



# MCMC settings
n_iter <- 10000
n_burn <- 2500
n_thin <- 2
n_chains <- 2

# Running the model
model <- jags.model(textConnection(model_string), data = data_jags, inits = inits, n.chains = n_chains)
update(model, n_burn)
samples <- coda.samples(model, variable.names = params, n.iter = n_iter / n_thin)

# Checking convergence
library(coda)
gelman.diag(samples)
autocorr.diag(samples)
effectiveSize(samples)

# Summarize the samples
summary(samples)

# Diagnostic Checks
print(gelman.diag(samples))
print(autocorr.diag(samples))
print(effectiveSize(samples))

# Plotting trace plots for visual inspection of convergence
library(coda)
traceplot(samples)

# Summarize the samples
summary(samples)

```

